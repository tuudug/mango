# Mango v0.2.2: Quest LLM Generation

**Goal:** Integrate LLM (e.g., Gemini) to generate daily and weekly quests and their criteria based on user data. Implement the generation/reset logic and UI controls.

**Prerequisites:** v0.2.1 (Quest Foundation) completed.

**1. Database Schema Changes:**

- **`quests` Table:**
  - Ensure `llm_prompt_context` (jsonb, nullable) and `llm_response_raw` (jsonb, nullable) columns exist.
  - Change default `source` to `'llm_generated'`.
- **`quest_criteria` Table:**
  - Ensure `config` (jsonb, nullable) column exists and is ready to store structured data like `{ "habit_id": "uuid", "target_count": 1 }`.
- **`user_quest_state` Table:**
  - Ensure all columns exist: `user_id`, `last_daily_generated_at`, `last_weekly_generated_at`, `next_weekly_reset_allowed_at`.

**2. Backend Implementation:**

- **LLM Integration (`geminiService.ts` or dedicated `questService.ts`):**
  - Implement `generateQuestsForUser(userId, type: 'daily' | 'weekly')`:
    - **Fetch User Data:** Gather relevant recent data (habits definitions & recent entries, recent steps, finance settings & recent entries, todo counts/activity, pomodoro usage, user level/path). Be mindful of data volume and privacy. Summarize where possible.
    - **Construct Prompt:** Develop a robust prompt instructing the LLM to:
      - Generate a specific number of quests (15 daily, 5 weekly) of the specified `type`.
      - For each quest, provide: `description` (user-facing text), `xp_reward` (integer, perhaps scaled by difficulty/type), and an array of `criteria`.
      - For each criterion, provide: `description` (user-facing text), `type` (must be one of the predefined enums: 'habit_check', 'steps_reach', etc.), and a `config` JSON object appropriate for the `type`.
      - Reference the available user data context in the prompt.
      - Specify the exact JSON output structure required.
    - **Call LLM:** Use the chosen LLM API (e.g., Gemini).
    - **Parse & Validate:**
      - Parse the LLM's JSON response.
      - Validate all fields, especially `criteria.type` against the enum.
      - **Crucially:** Map habit names/descriptions mentioned in criteria back to actual `habit_id`s from the user's data to populate `config.habit_id`. Handle cases where the LLM hallucinates non-existent habits.
      - Assign reasonable default `xp_reward` if not provided or invalid.
    - **Store Results:**
      - Insert valid quests (`status: 'available'`, `source: 'llm_generated'`) and their criteria into the database.
      - Store the summarized `llm_prompt_context` and the `llm_response_raw` for debugging/auditing.
      - Update `last_daily_generated_at` or `last_weekly_generated_at` in `user_quest_state`.
      - Calculate and update `next_weekly_reset_allowed_at` (e.g., next Sunday 8 PM in user's timezone) if weekly quests were generated/reset.
- **Quest Management API Routes:**
  - Implement `POST /api/quests/generate`:
    - **Input:** `{ type: 'daily' | 'weekly' }`
    - **Logic:**
      - Fetch `user_quest_state` for the user.
      - Read the `X-User-Timezone` header.
      - Check timing rules:
        - Allow initial generation if `last_..._generated_at` is null.
        - Allow daily reset if it's a new day (based on user timezone) since `last_daily_generated_at`.
        - Allow weekly reset if current time is past `next_weekly_reset_allowed_at`.
      - If generation/reset is allowed:
        - Delete existing 'available' quests of the specified `type` for the user.
        - Call `generateQuestsForUser(userId, type)`.
        - Return the newly generated 'available' quests (or success/failure message).
      - If not allowed, return an appropriate error message (e.g., "Reset not available yet").

**3. Frontend Implementation:**

- **Context (`QuestsContext.tsx`):**
  - Add state to store `generationState` (fetched from `user_quest_state` via a new API endpoint or included in `GET /api/quests` response). Include `lastDailyGeneratedAt`, `lastWeeklyGeneratedAt`, `nextWeeklyResetAllowedAt`.
  - Implement `generateOrResetQuests(type: 'daily' | 'weekly')`:
    - Calls `POST /api/quests/generate` with the type.
    - Handles loading state.
    - On success, refreshes the list of available quests (`fetchQuests`).
    - Displays success/error toasts.
- **UI (`QuestsPanel.tsx`):**
  - **Generate/Reset Buttons:**
    - Add "Generate Daily Quests" / "Reset Daily Quests" button. Show conditionally based on `generationState.lastDailyGeneratedAt` and current date (user's timezone).
    - Add "Generate Weekly Quests" / "Reset Weekly Quests" button. Show conditionally based on `generationState.lastWeeklyGeneratedAt` and `generationState.nextWeeklyResetAllowedAt`.
    - Buttons call `generateOrResetQuests` from the context. Disable buttons during loading state.
  - Display generated quests in the "Available Quests" pool.

**Testing:**

- Test the LLM prompt with various user data scenarios.
- Verify the parsing and validation logic, especially the mapping of habit names to IDs.
- Test the generation/reset API endpoint with different timing scenarios and timezones.
- Test the frontend buttons and state updates.
- Manually verify that generated quests and criteria are stored correctly in the database.
