# Mango v0.2.2: Quest LLM Generation

**Goal:** Integrate LLM (e.g., Gemini) to generate daily and weekly quests and their criteria based on user data. Implement the generation/reset logic, UI controls, and display user XP/Level.

**Prerequisites:** v0.2.1 (Quest Foundation) completed.

**1. Database Schema Changes:**

- **`user_progress` Table (Create if not exists):**

  - This table is required for storing XP gained from quests.
  - **Columns:**
    - `user_id` (uuid, pk, fk to auth.users)
    - `xp` (integer, not null, default: 0)
    - `level` (integer, not null, default: 1) - _Level calculation logic TBD_
    - `created_at` (timestampz, default: now())
    - `updated_at` (timestampz, default: now())
  - **RLS:** Allow individual user access.
  - **Trigger:** `handle_updated_at` on `updated_at`.
  - **SQL:**

    ```sql
    -- User Progress Table (for XP/Level)
    CREATE TABLE IF NOT EXISTS public.user_progress (
        user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
        xp integer NOT NULL DEFAULT 0,
        level integer NOT NULL DEFAULT 1,
        created_at timestamp with time zone NOT NULL DEFAULT now(),
        updated_at timestamp with time zone NOT NULL DEFAULT now()
    );

    -- RLS for user_progress table
    ALTER TABLE public.user_progress ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS "Allow individual user access for user_progress" ON public.user_progress;
    CREATE POLICY "Allow individual user access for user_progress" ON public.user_progress
        FOR ALL
        USING (auth.uid() = user_id);

    -- Trigger for updated_at on user_progress
    DROP TRIGGER IF EXISTS handle_updated_at ON public.user_progress;
    CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.user_progress
      FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

    -- Grant permissions
    GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.user_progress TO authenticated;
    ```

- **`quests` Table:**
  - Ensure `llm_prompt_context` (jsonb, nullable) and `llm_response_raw` (jsonb, nullable) columns exist.
  - Change default `source` to `'llm_generated'`.
- **`quest_criteria` Table:**
  - Ensure `config` (jsonb, nullable) column exists and is ready to store structured data like `{ "habit_id": "uuid", "target_count": 1 }`.
- **`user_quest_state` Table:**
  - Ensure all columns exist: `user_id`, `last_daily_generated_at`, `last_weekly_generated_at`, `next_weekly_reset_allowed_at`.

**2. Backend Implementation:**

- **XP & Leveling:**
  - **Define Level Thresholds:** Establish a clear mapping between total XP and user levels (e.g., Level 2 at 100 XP, Level 3 at 250 XP, etc.). Store this in a configuration file or constants.
  - **Update `addXp` Endpoint/Service:** Modify the `POST /api/user/progress/add-xp` endpoint (or the refactored service function) to:
    - Calculate the user's new level based on their updated total XP and the defined thresholds.
    - Update both the `xp` and `level` columns in the `user_progress` table.
  - **Fix `claimQuest`:** Modify the `claimQuest` handler (`api/src/routes/quests/claimQuest.ts`) to correctly call the `addXp` logic (either via internal API or preferably a shared service function) upon successful quest claim.
  - **User Progress Endpoint:** Create a `GET /api/user/progress` endpoint that returns the current user's `xp` and `level` from the `user_progress` table.
- **LLM Integration (`geminiService.ts` or dedicated `questService.ts`):**
  - Implement `generateQuestsForUser(userId, type: 'daily' | 'weekly')`:
    - **Fetch User Data:** Gather relevant recent data (habits definitions & recent entries, recent steps, finance settings & recent entries, todo counts/activity, pomodoro usage, user level/path from `user_progress`). Be mindful of data volume and privacy. Summarize where possible.
    - **Construct Prompt:** Develop a robust prompt instructing the LLM to:
      - Generate a specific number of quests (15 daily, 5 weekly) of the specified `type`.
      - For each quest, provide: `description` (user-facing text), `xp_reward` (integer, perhaps scaled by difficulty/type), and an array of `criteria`.
      - For each criterion, provide: `description` (user-facing text), `type` (must be one of the predefined enums: 'habit_check', 'steps_reach', etc.), and a `config` JSON object appropriate for the `type`.
      - Reference the available user data context in the prompt.
      - Specify the exact JSON output structure required.
    - **Call LLM:** Use the chosen LLM API (e.g., Gemini).
    - **Parse & Validate:**
      - Parse the LLM's JSON response.
      - Validate all fields, especially `criteria.type` against the enum.
      - **Crucially:** Map habit names/descriptions mentioned in criteria back to actual `habit_id`s from the user's data to populate `config.habit_id`. Handle cases where the LLM hallucinates non-existent habits.
      - Assign reasonable default `xp_reward` if not provided or invalid.
    - **Store Results:**
      - Insert valid quests (`status: 'available'`, `source: 'llm_generated'`) and their criteria into the database.
      - Store the summarized `llm_prompt_context` and the `llm_response_raw` for debugging/auditing.
      - Update `last_daily_generated_at` or `last_weekly_generated_at` in `user_quest_state`.
      - Calculate and update `next_weekly_reset_allowed_at` (e.g., next Sunday 8 PM in user's timezone) if weekly quests were generated/reset.
- **Quest Management API Routes:**
  - Implement `POST /api/quests/generate`:
    - **Input:** `{ type: 'daily' | 'weekly' }`
    - **Logic:**
      - Fetch `user_quest_state` for the user.
      - Read the `X-User-Timezone` header.
      - Check timing rules:
        - Allow initial generation if `last_..._generated_at` is null.
        - Allow daily reset if it's a new day (based on user timezone) since `last_daily_generated_at`.
        - Allow weekly reset if current time is past `next_weekly_reset_allowed_at`.
      - If generation/reset is allowed:
        - Delete existing 'available' quests of the specified `type` for the user.
        - Call `generateQuestsForUser(userId, type)`.
        - Return the newly generated 'available' quests (or success/failure message).
      - If not allowed, return an appropriate error message (e.g., "Reset not available yet").

**3. Frontend Implementation:**

- **Context (`AuthContext.tsx`):**
  - Add state to store user progress (`xp`, `level`).
  - Modify the context to fetch user progress data (e.g., from `GET /api/user/progress` or session login) and update the state.
  - Provide a way to refresh this progress data (e.g., a `fetchUserProgress` function).
- **Context (`QuestsContext.tsx`):**
  - Add state to store `generationState` (fetched from `user_quest_state` via a new API endpoint or included in `GET /api/quests` response). Include `lastDailyGeneratedAt`, `lastWeeklyGeneratedAt`, `nextWeeklyResetAllowedAt`.
  - Implement `generateOrResetQuests(type: 'daily' | 'weekly')`:
    - Calls `POST /api/quests/generate` with the type.
    - Handles loading state.
    - On success, refreshes the list of available quests (`fetchQuests`).
    - Displays success/error toasts.
  - Modify `claimQuest` function to call the `fetchUserProgress` function from `AuthContext` after a successful claim to update the UI.
- **UI (`QuestsPanel.tsx`):**
  - **Generate/Reset Buttons:**
    - Add "Generate Daily Quests" / "Reset Daily Quests" button. Show conditionally based on `generationState.lastDailyGeneratedAt` and current date (user's timezone).
    - Add "Generate Weekly Quests" / "Reset Weekly Quests" button. Show conditionally based on `generationState.lastWeeklyGeneratedAt` and `generationState.nextWeeklyResetAllowedAt`.
    - Buttons call `generateOrResetQuests` from the context. Disable buttons during loading state.
  - Display generated quests in the "Available Quests" pool.
- **UI (XP/Level Display):**
  - Update the component responsible for displaying Level/XP (e.g., `LeftSidebar.tsx` in the user profile section) to consume the `xp` and `level` state from `AuthContext` instead of showing placeholder text.

**Testing:**

- Test the LLM prompt with various user data scenarios.
- Verify the parsing and validation logic, especially the mapping of habit names to IDs.
- Test the generation/reset API endpoint with different timing scenarios and timezones.
- Test the frontend buttons and state updates.
- Manually verify that generated quests and criteria are stored correctly in the database.
- Verify `user_progress` table is created and XP/Level updates correctly when quests are claimed.
- Verify the UI correctly displays the user's current XP and Level.
