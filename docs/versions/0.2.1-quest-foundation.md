# Mango v0.2.1: Quest System Foundation

**Goal:** Establish the basic database structure, UI panels, context, and API endpoints for managing quests manually, without LLM generation or automatic progress tracking yet. Focus on the core lifecycle: Available -> Active -> Claimable -> Completed/Cancelled.

**1. Database Schema (Supabase):**

- **`quests` Table:**
  - `id` (uuid, pk)
  - `user_id` (uuid, fk to users, index)
  - `description` (text) - _Manually entered for now_
  - `xp_reward` (integer) - _Manually entered for now_
  - `status` (enum: 'available', 'active', 'claimable', 'completed', 'cancelled') - Default 'available'.
  - `type` (enum: 'daily', 'weekly') - _Manually assigned for now_
  - `source` (enum: 'manual', 'llm_generated') - Default 'manual' for this version.
  - `generated_at` (timestampz, default: now())
  - `activated_at` (timestampz, nullable)
  - `claimable_at` (timestampz, nullable) - _Set manually via API for testing_
  - `completed_at` (timestampz, nullable)
  - `cancelled_at` (timestampz, nullable)
- **`quest_criteria` Table:**
  - `id` (uuid, pk)
  - `quest_id` (uuid, fk to quests, index)
  - `description` (text) - _Manually entered for now_
  - `type` (enum: 'habit*check', 'steps_reach', 'finance_under_allowance', 'pomodoro_session', 'todo_complete') - \_Informational only for now*
  - `config` (jsonb, nullable) - _Informational only for now_
  - `current_progress` (integer, default: 0) - _Not automatically updated yet_
  - `is_met` (boolean, default: false, index) - _Set manually via API for testing_
  - `created_at` (timestampz, default: now())
- **`user_quest_state` Table:**
  - `user_id` (uuid, pk, fk to users)
  - `last_daily_generated_at` (timestampz, nullable) - _Not used yet_
  - `last_weekly_generated_at` (timestampz, nullable) - _Not used yet_
  - `next_weekly_reset_allowed_at` (timestampz) - _Not used yet_

**2. Backend API Routes:**

- **CRUD for Manual Setup (Internal/Admin Tools or direct DB access initially):**
  - Need a way to insert sample quests and criteria for testing.
- **Core User Routes:**
  - `GET /api/quests`:
    - Accept query params: `status`, `type`.
    - Return quests with their associated `quest_criteria`.
  - `POST /api/quests/:questId/activate`:
    - Check active quest limits (2 daily, 4 weekly).
    - Change quest `status` to 'active', set `activated_at`.
  - `POST /api/quests/:questId/cancel`:
    - Change quest `status` to 'cancelled', set `cancelled_at`.
  - `POST /api/quests/:questId/claim`:
    - **Input:** `questId`
    - **Logic:**
      - Verify quest belongs to user and `status` is `'claimable'`.
      - Update quest `status` to `'completed'`, set `completed_at`.
      - Call `POST /api/user/progress/add-xp` (ensure this XP endpoint exists from the base v0.2 plan).
      - Return success/updated quest state.
  - **(Testing Only) `POST /api/quests/:questId/set-claimable`:**
    - Manually sets the quest status to 'claimable' and `claimable_at`.
  - **(Testing Only) `POST /api/criteria/:criterionId/set-met`:**
    - Manually sets `is_met` to true for a criterion.

**3. Frontend Implementation:**

- **New Panel (`src/components/datasources/QuestsPanel.tsx`):**
  - Add button to `LeftSidebar.tsx` and entry to `dataSourceConfig.ts` (e.g., `Target` icon).
  - **Sections:** "Daily Quests", "Weekly Quests".
  - **Sub-Sections:** "Active Slots", "Available Quests".
- **New Context (`src/contexts/QuestsContext.tsx`):**
  - `useQuests` hook.
  - State: `activeDaily`, `activeWeekly`, `availableDaily`, `availableWeekly` quests (fetched from `GET /api/quests`).
  - Functions:
    - `fetchQuests()`: Calls `GET /api/quests`.
    - `activateQuest(questId)`: Calls `POST /api/quests/:questId/activate`, updates local state.
    - `cancelQuest(questId)`: Calls `POST /api/quests/:questId/cancel`, updates local state.
    - `claimQuest(questId)`: Calls `POST /api/quests/:questId/claim`, updates local state, triggers auth context refresh for XP/Level.
- **UI (`QuestsPanel.tsx`):**
  - **Active Slots:** Display quests. Show description, XP. List criteria, show `criterion.description`. If quest `status` is 'claimable', show "Claim Reward" button (calls `claimQuest`). Otherwise, show "Cancel" button (calls `cancelQuest`).
  - **Available Pool:** Display list of available quests. Show description, XP. Add "Activate" button (calls `activateQuest`, disabled if active slots full).
  - No generation/reset buttons yet.
  - No automatic progress display on criteria yet.

**4. XP System Integration:**

- Ensure the basic XP/Level display in `LeftSidebar.tsx` (from base v0.2 plan) is functional and consumes data from `AuthContext`.
- Ensure the backend `POST /api/user/progress/add-xp` endpoint exists and updates user XP/Level.
- The `claimQuest` function should trigger an update/refresh of the user's auth data to reflect the new XP/Level.

**Testing:** Manually insert quests/criteria into the database. Use testing API endpoints or direct DB manipulation to change criteria `is_met` status and quest `status` to 'claimable' to test the activate, cancel, and claim flows.

Note: This SQL query has already been executed on the Supabase Database. You can skip the Database creation steps.

```sql
-- Enum types (create if they don't exist, or ensure they include these values)
-- Note: You might already have some enums from other features.
-- Add 'available', 'active', 'claimable', 'completed', 'cancelled' to quest_status enum if it exists, otherwise create it.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'quest_status') THEN
        CREATE TYPE public.quest_status AS ENUM (
            'available',
            'active',
            'claimable',
            'completed',
            'cancelled'
        );
    END IF;
END$$;

-- Add 'daily', 'weekly' to quest_type enum if it exists, otherwise create it.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'quest_type') THEN
        CREATE TYPE public.quest_type AS ENUM (
            'daily',
            'weekly'
        );
    END IF;
END$$;

-- Add 'manual', 'llm_generated' to quest_source enum if it exists, otherwise create it.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'quest_source') THEN
        CREATE TYPE public.quest_source AS ENUM (
            'manual',
            'llm_generated'
        );
    END IF;
END$$;

-- Add 'habit_check', 'steps_reach', 'finance_under_allowance', 'pomodoro_session', 'todo_complete' to quest_criteria_type enum if it exists, otherwise create it.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'quest_criteria_type') THEN
        CREATE TYPE public.quest_criteria_type AS ENUM (
            'habit_check',
            'steps_reach',
            'finance_under_allowance',
            'pomodoro_session',
            'todo_complete'
        );
    END IF;
END$$;


-- Quests Table
CREATE TABLE IF NOT EXISTS public.quests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    description text NOT NULL,
    xp_reward integer NOT NULL DEFAULT 10,
    status public.quest_status NOT NULL DEFAULT 'available'::public.quest_status,
    type public.quest_type NOT NULL DEFAULT 'daily'::public.quest_type,
    source public.quest_source NOT NULL DEFAULT 'manual'::public.quest_source,
    generated_at timestamp with time zone NOT NULL DEFAULT now(),
    activated_at timestamp with time zone,
    claimable_at timestamp with time zone,
    completed_at timestamp with time zone,
    cancelled_at timestamp with time zone,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Indexes for quests table
CREATE INDEX IF NOT EXISTS idx_quests_user_id ON public.quests(user_id);
CREATE INDEX IF NOT EXISTS idx_quests_user_id_status ON public.quests(user_id, status);
CREATE INDEX IF NOT EXISTS idx_quests_user_id_type ON public.quests(user_id, type);

-- RLS for quests table
ALTER TABLE public.quests ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow individual user access for quests" ON public.quests;
CREATE POLICY "Allow individual user access for quests" ON public.quests
    FOR ALL
    USING (auth.uid() = user_id);

-- Trigger for updated_at on quests
DROP TRIGGER IF EXISTS handle_updated_at ON public.quests;
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.quests
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);


-- Quest Criteria Table
CREATE TABLE IF NOT EXISTS public.quest_criteria (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    quest_id uuid NOT NULL REFERENCES public.quests(id) ON DELETE CASCADE,
    description text NOT NULL,
    type public.quest_criteria_type NOT NULL,
    config jsonb,
    target_count integer NOT NULL DEFAULT 1, -- Added target_count based on v0.2.3 plan for clarity
    current_progress integer NOT NULL DEFAULT 0,
    is_met boolean NOT NULL DEFAULT false,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now() -- Added updated_at
);

-- Indexes for quest_criteria table
CREATE INDEX IF NOT EXISTS idx_quest_criteria_quest_id ON public.quest_criteria(quest_id);
CREATE INDEX IF NOT EXISTS idx_quest_criteria_is_met ON public.quest_criteria(is_met);

-- RLS for quest_criteria table
ALTER TABLE public.quest_criteria ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow user access based on quest ownership for criteria" ON public.quest_criteria;
CREATE POLICY "Allow user access based on quest ownership for criteria" ON public.quest_criteria
    FOR ALL
    USING (
      EXISTS (
        SELECT 1
        FROM public.quests q
        WHERE q.id = quest_id AND q.user_id = auth.uid()
      )
    );

-- Trigger for updated_at on quest_criteria
DROP TRIGGER IF EXISTS handle_updated_at ON public.quest_criteria;
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.quest_criteria
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);


-- User Quest State Table (for tracking generation/reset times later)
CREATE TABLE IF NOT EXISTS public.user_quest_state (
    user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    last_daily_generated_at timestamp with time zone,
    last_weekly_generated_at timestamp with time zone,
    next_weekly_reset_allowed_at timestamp with time zone,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now()
);

-- RLS for user_quest_state table
ALTER TABLE public.user_quest_state ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow individual user access for user_quest_state" ON public.user_quest_state;
CREATE POLICY "Allow individual user access for user_quest_state" ON public.user_quest_state
    FOR ALL
    USING (auth.uid() = user_id);

-- Trigger for updated_at on user_quest_state
DROP TRIGGER IF EXISTS handle_updated_at ON public.user_quest_state;
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.user_quest_state
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- Grant usage on new types to authenticated role if needed
GRANT USAGE ON TYPE public.quest_status TO authenticated;
GRANT USAGE ON TYPE public.quest_type TO authenticated;
GRANT USAGE ON TYPE public.quest_source TO authenticated;
GRANT USAGE ON TYPE public.quest_criteria_type TO authenticated;

-- Grant permissions on new tables to authenticated role
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.quests TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.quest_criteria TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.user_quest_state TO authenticated;

-- Grant usage on sequences if needed (Supabase usually handles this)
-- GRANT USAGE, SELECT ON SEQUENCE quests_id_seq TO authenticated; -- Example if using serial
-- GRANT USAGE, SELECT ON SEQUENCE quest_criteria_id_seq TO authenticated; -- Example if using serial
```
